%%  MCMCcuedYesNo.m
%
%%

function [AUC, AUC_valid_present, AUC_invalid_present, ...
	validHR, invalidHR] = MCMCcuedYesNo(mcmcparams, N, variance, cue_validity, TRIALS)
%  N=4; variance = 1; cue_validity=0.5; TRIALS =1000;

%% Preliminaries
JAGSmodel = 'JAGScueddetection.txt';


%% STEP 1: GENERATE SIMULATED DATASET
% Place observed variables into the structure |params| to pass to JAGS
params.N 				= N;
params.T                = 1;% simulate 1 trial, but generate many MCMC samples, see below
params.v                = cue_validity;
params.varT         = variance;
params.varD         = variance;
params.uniformdist      = ones(N,1)./N; % uniform distribution, for cue location

%%
% Set initial values for latent variable in each chain

for i=1:mcmcparams.generate.nchains
    %initial_param(i).L			= randi(params.N);
    
    % The guess initial parameter value for L cannot equal a location who's
    % spatial prior is equal to zero, otherwise we get an error message
    % from JAGS.
    
    initial_param(i).D = round( ( rand*(N)) +1);
end

%%
% Calling JAGS to generate simulated data
%fprintf( 'Running JAGS...\n' );
%tic
[dataset, stats, structArray] = matjags( ...
    params, ...
    fullfile(pwd, JAGSmodel), ...
    initial_param, ...
    'doparallel' , mcmcparams.doparallel, ...
    'nchains', mcmcparams.generate.nchains,...
    'nburnin', mcmcparams.generate.nburnin,...
    'nsamples', mcmcparams.generate.nsamples, ...
    'thin', 1, ...
    'monitorparams', {'c','D','x'}, ...
    'savejagsoutput' , 0 , ...
    'verbosity' , 1 , ...
    'cleanup' , 1 ,...
    'rndseed',1,...
    'dic',0);


clear initial_param


%%
% grab true locations from the dataset made in step 1
true_location = squeeze(dataset.D);









%% STEP 2: INFER THE TRIAL TYPE GIVEN THE SENSORY OBSERVATIONS
% Now do inference on ALL the generated data

% now we MAY OR MAY NOT want to remove knowledge that L is sampled from a uniform distribution over each location (pdist=[1/N ... 1/N])
%params = rmfield(params, 'pdist')

%%
% update some of the parameters
params.x		= squeeze(dataset.x)';
params.T		= TRIALS;
params.c		= squeeze(dataset.c)';

%%
% Set initial values for latent variable in each chain
for i=1:mcmcparams.infer.nchains
	initial_param(i).D			= randi(params.N+1, TRIALS,1);
end

%%
% Calling JAGS to sample
[samples, stats, structArray] = matjags( ...
    params, ...
    fullfile(pwd, JAGSmodel), ...
    initial_param, ...
    'doparallel' , mcmcparams.doparallel, ...
    'nchains', mcmcparams.infer.nchains,...
    'nburnin', mcmcparams.infer.nburnin,...
    'nsamples', mcmcparams.infer.nsamples, ...
    'thin', 1, ...
    'monitorparams', {'D'}, ...
    'savejagsoutput' , 0 , ...
    'verbosity' , 1 , ...
    'cleanup' , 1 ,...
    'rndseed',1);


% %%
% % Extract the MCMC samples and use them to calculate the performance
% % (proportion correct, |PC|).
% 
% for t=1:TRIALS
%     D(t)		= mode( vec(samples.D(:,:,t)) );
% end
% 
% % Examine the performance of the optimal observer
% Ncorrect = sum( D==true_location );
% [PC, PCI] = binofit(Ncorrect,TRIALS);


%% STEP 3: Decision step

%%
% Calculate the decision variable for all trials. This is the posterior
% probability of the L indicating target presence, i.e. L={1,...,N} and not
% L=N+1 (indicating target absence).

% preallocate
Ppresent = zeros(params.T,1);
response = zeros(params.T,1);
for t=1:params.T
	% grab the MCMC samples of L for this trial, for all chains
	temp = vec( samples.D(:,:,t) );
	
	% Calculate the distribution over D (for each trial) as generated by the
	% MCMC samples
	[Dfreq,d] = hist(temp,[1:params.N+1]);
	
	% Normalise into a probability disibution over L.
	Dprob=Dfreq./sum(Dfreq);
	
	% Calculate the decision variable... the posterior probability the target
	% is present, i.e. the probability mass corresponding to L={1,...,N}
	Ppresent(t) = sum( Dprob([1:N]) );
	
	% What is the response of an unbiased observer?
	if Ppresent(t)>=0.5
		response(t)=1;
	else
		response(t)=0;
	end
end



% new ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
nValidHits = 0;	
nValidPresent = 0;
nInvalidHits = 0;	
nInvalidPresent = 0;

setValidHitTrials = zeros(params.T,1);
setInvalidHitTrials = zeros(params.T,1);

for t=1:params.T
	
	% Is this a target-present, valud-cue trial?
	if dataset.D(t)<=params.N && dataset.c(t)==dataset.D(t)
		nValidPresent = nValidPresent+1;
		
		% did the observer also get it right? A hit.
		if response(t)==1
			nValidHits = nValidHits+1;
			
			setValidHitTrials(t) = 1; % label as a validHit trial
		end
	end
	
	% Is this a target-present, INvalud-cue trial?
	if dataset.D(t)<=params.N && dataset.c(t)~=dataset.D(t)
		nInvalidPresent = nInvalidPresent+1;
		
		% did the observer also get it right? A hit.
		if response(t)==1
			nInvalidHits = nInvalidHits+1;
			
			setInvalidHitTrials(t) = 1; % label as a validHit trial
		end
	end
	
end
% nValidHits
% nValidPresent
validHR = nValidHits / nValidPresent;

% nInvalidHits
% nInvalidPresent
invalidHR = nInvalidHits / nInvalidPresent;
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





% From step 2, we have calculated the posterior distribution over L, for
% each trial, $P(L,x|params)$. If we were dealing with a real experimental
% participant, all we could observe would be their behavioural response,
% but because this is an optimal observer model we have direct access to
% their posterior distribution over target presence/absence. This can be used
% in order to generate ROC curves.
%
% The approach will be to extract the posterior probability of target
% presence for signal (target present) and noise (target absent) trials,
% and then use this to calculate an ROC curve by considering a large number
% of potential decision thresholds.
%


% First, create binary vectors to label the signal (target present) and noise
% (target absent) trials.
present_trials	= dataset.D<=params.N;
absent_trials	= dataset.D==params.N+1;

% % There should be about `(cue_validity*0.5)*TRIALS` valid present trials
% valid_present_trials = dataset.D==dataset.c;
% % There should be about `((1-cue_validity)*0.5)*TRIALS` invalid present trials
% %invalid_present_trials = dataset.D~=dataset.c; %<--- incorrect
% %invalid_present_trials = dataset.D(present_trials)~=dataset.c(present_trials);
% invalid_present_trials = dataset.D(present_trials==1)~=dataset.c(present_trials==1);
% invalid_present_trials = (dataset.D~=dataset.c)==1 && present_trials==1;
% 
% 
% %% Calculate the valid hit rate, and invalid hit rate
% 
% % old code
% NvalidPresent = sum(valid_present_trials);
% NinvalidPresent = sum(invalid_present_trials);
% 
% %all_hits	= present_trials' == response;
% %all_hits	= present_trials(response==1);
% 
% nValidHits		= sum(valid_present_trials(response==1));
% validHR			= nValidHits / NvalidPresent;
% 
% nInvalidHits	= sum( dataset.D(present_trials(response==1))~=dataset.c(present_trials(response==1)) );
% invalidHR		= nInvalidHits / NinvalidPresent; 
% 
% % new
% % NvalidPresent	= sum(valid_present_trials==1);
% % NvalidHits		= sum(valid_present_trials(response==1)==1);
% % validHR			= NvalidHits/NvalidPresent;
% % 
% % NinvalidPresent	= sum(invalid_present_trials==1);
% % NinvalidHits		= sum(invalid_present_trials(response==1)==1);
% % invalidHR			= NinvalidHits/NinvalidPresent;
% % 
% 
% % % set counters
% % FA=0;
% % CR=0;
% % vHIT=0; iHIT =0;
% % vMISS=0; iMISS=0;
% % for t=1:params.T
% % 	% false alarms
% % 	if dataset.D(t)==N+1 && response(t)==1
% % 		FA = FA+1;
% % 	end
% % 	
% % 	% valid hits
% % 	if dataset.D(t)==dataset.c(t) && dataset.D(t)<N+1 && response(t)==1
% % 		vHIT = vHIT+1;
% % 	end
% % 	
% % 	% invalid hits
% % 	if dataset.D(t)~=dataset.c(t) && dataset.D(t)<N+1 && response(t)==1
% % 		iHIT = iHIT+1;
% % 	end
% % end

%% 
% Grab the decision variables for the signal and the noise trials
S = Ppresent(present_trials);
N = Ppresent(absent_trials);
% Use that to calculate ROC curve with the function
% |ROC_calcHRandFAR_VECTORIZED|.
[HR, FAR, AUC]=ROC_calcHRandFAR_VECTORIZED(N,S);

% Grab the decision variables for the signal and the noise trials

% old
% VP = Ppresent(valid_present_trials);
% IP = Ppresent(invalid_present_trials);
% new
VP = Ppresent(setValidHitTrials==1);
IP = Ppresent(setInvalidHitTrials==1);



% Use that to calculate ROC curve with the function
% |ROC_calcHRandFAR_VECTORIZED|.
[HR, FAR, AUC_valid_present]=ROC_calcHRandFAR_VECTORIZED(N,VP);

figure(5), clf
subplot(2,2,1), hist_compare(N,VP,linspace(0,1,50))
xlabel('P(present)')
title('valid')

subplot(2,2,3), plot(FAR, HR), hold on, plot([0 1],[0 1],'k-')

[HR, FAR, AUC_invalid_present]=ROC_calcHRandFAR_VECTORIZED(N,IP);

subplot(2,2,2), hist_compare(N,IP,linspace(0,1,50))
xlabel('decision variable, P(present)')
title('invalid')

subplot(2,2,4), plot(FAR, HR), hold on, plot([0 1],[0 1],'k-')

drawnow

return