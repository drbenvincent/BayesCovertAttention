
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>export_fig</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-01-24"><meta name="DC.source" content="export_fig.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%EXPORT_FIG  Exports figures suitable for publication</span>
<span class="comment">%</span>
<span class="comment">% Examples:</span>
<span class="comment">%   im = export_fig</span>
<span class="comment">%   [im alpha] = export_fig</span>
<span class="comment">%   export_fig filename</span>
<span class="comment">%   export_fig filename -format1 -format2</span>
<span class="comment">%   export_fig ... -nocrop</span>
<span class="comment">%   export_fig ... -transparent</span>
<span class="comment">%   export_fig ... -native</span>
<span class="comment">%   export_fig ... -m&lt;val&gt;</span>
<span class="comment">%   export_fig ... -r&lt;val&gt;</span>
<span class="comment">%   export_fig ... -a&lt;val&gt;</span>
<span class="comment">%   export_fig ... -q&lt;val&gt;</span>
<span class="comment">%   export_fig ... -&lt;renderer&gt;</span>
<span class="comment">%   export_fig ... -&lt;colorspace&gt;</span>
<span class="comment">%   export_fig ... -append</span>
<span class="comment">%   export_fig ... -bookmark</span>
<span class="comment">%   export_fig(..., handle)</span>
<span class="comment">%</span>
<span class="comment">% This function saves a figure or single axes to one or more vector and/or</span>
<span class="comment">% bitmap file formats, and/or outputs a rasterized version to the</span>
<span class="comment">% workspace, with the following properties:</span>
<span class="comment">%   - Figure/axes reproduced as it appears on screen</span>
<span class="comment">%   - Cropped borders (optional)</span>
<span class="comment">%   - Embedded fonts (vector formats)</span>
<span class="comment">%   - Improved line and grid line styles</span>
<span class="comment">%   - Anti-aliased graphics (bitmap formats)</span>
<span class="comment">%   - Render images at native resolution (optional for bitmap formats)</span>
<span class="comment">%   - Transparent background supported (pdf, eps, png)</span>
<span class="comment">%   - Semi-transparent patch objects supported (png only)</span>
<span class="comment">%   - RGB, CMYK or grayscale output (CMYK only with pdf, eps, tiff)</span>
<span class="comment">%   - Variable image compression, including lossless (pdf, eps, jpg)</span>
<span class="comment">%   - Optionally append to file (pdf, tiff)</span>
<span class="comment">%   - Vector formats: pdf, eps</span>
<span class="comment">%   - Bitmap formats: png, tiff, jpg, bmp, export to workspace</span>
<span class="comment">%</span>
<span class="comment">% This function is especially suited to exporting figures for use in</span>
<span class="comment">% publications and presentations, because of the high quality and</span>
<span class="comment">% portability of media produced.</span>
<span class="comment">%</span>
<span class="comment">% Note that the background color and figure dimensions are reproduced</span>
<span class="comment">% (the latter approximately, and ignoring cropping &amp; magnification) in the</span>
<span class="comment">% output file. For transparent background (and semi-transparent patch</span>
<span class="comment">% objects), use the -transparent option or set the figure 'Color' property</span>
<span class="comment">% to 'none'. To make axes transparent set the axes 'Color' property to</span>
<span class="comment">% 'none'. Pdf, eps and png are the only file formats to support a</span>
<span class="comment">% transparent background, whilst the png format alone supports transparency</span>
<span class="comment">% of patch objects.</span>
<span class="comment">%</span>
<span class="comment">% The choice of renderer (opengl, zbuffer or painters) has a large impact</span>
<span class="comment">% on the quality of output. Whilst the default value (opengl for bitmaps,</span>
<span class="comment">% painters for vector formats) generally gives good results, if you aren't</span>
<span class="comment">% satisfied then try another renderer.  Notes: 1) For vector formats (eps,</span>
<span class="comment">% pdf), only painters generates vector graphics. 2) For bitmaps, only</span>
<span class="comment">% opengl can render transparent patch objects correctly. 3) For bitmaps,</span>
<span class="comment">% only painters will correctly scale line dash and dot lengths when</span>
<span class="comment">% magnifying or anti-aliasing. 4) Fonts may be substitued with Courier when</span>
<span class="comment">% using painters.</span>
<span class="comment">%</span>
<span class="comment">% When exporting to vector format (pdf &amp; eps) and bitmap format using the</span>
<span class="comment">% painters renderer, this function requires that ghostscript is installed</span>
<span class="comment">% on your system. You can download this from:</span>
<span class="comment">%   http://www.ghostscript.com</span>
<span class="comment">% When exporting to eps it additionally requires pdftops, from the Xpdf</span>
<span class="comment">% suite of functions. You can download this from:</span>
<span class="comment">%   http://www.foolabs.com/xpdf</span>
<span class="comment">%</span>
<span class="comment">%IN:</span>
<span class="comment">%   filename - string containing the name (optionally including full or</span>
<span class="comment">%              relative path) of the file the figure is to be saved as. If</span>
<span class="comment">%              a path is not specified, the figure is saved in the current</span>
<span class="comment">%              directory. If no name and no output arguments are specified,</span>
<span class="comment">%              the default name, 'export_fig_out', is used. If neither a</span>
<span class="comment">%              file extension nor a format are specified, a ".png" is added</span>
<span class="comment">%              and the figure saved in that format.</span>
<span class="comment">%   -format1, -format2, etc. - strings containing the extensions of the</span>
<span class="comment">%                              file formats the figure is to be saved as.</span>
<span class="comment">%                              Valid options are: '-pdf', '-eps', '-png',</span>
<span class="comment">%                              '-tif', '-jpg' and '-bmp'. All combinations</span>
<span class="comment">%                              of formats are valid.</span>
<span class="comment">%   -nocrop - option indicating that the borders of the output are not to</span>
<span class="comment">%             be cropped.</span>
<span class="comment">%   -transparent - option indicating that the figure background is to be</span>
<span class="comment">%                  made transparent (png, pdf and eps output only).</span>
<span class="comment">%   -m&lt;val&gt; - option where val indicates the factor to magnify the</span>
<span class="comment">%             on-screen figure dimensions by when generating bitmap</span>
<span class="comment">%             outputs. Default: '-m1'.</span>
<span class="comment">%   -r&lt;val&gt; - option val indicates the resolution (in pixels per inch) to</span>
<span class="comment">%             export bitmap outputs at, keeping the dimensions of the</span>
<span class="comment">%             on-screen figure. Default: sprintf('-r%g', get(0,</span>
<span class="comment">%             'ScreenPixelsPerInch')). Note that the -m and -r options</span>
<span class="comment">%             change the same property.</span>
<span class="comment">%   -native - option indicating that the output resolution (when outputting</span>
<span class="comment">%             a bitmap format) should be such that the vertical resolution</span>
<span class="comment">%             of the first suitable image found in the figure is at the</span>
<span class="comment">%             native resolution of that image. To specify a particular</span>
<span class="comment">%             image to use, give it the tag 'export_fig_native'. Notes:</span>
<span class="comment">%             This overrides any value set with the -m and -r options. It</span>
<span class="comment">%             also assumes that the image is displayed front-to-parallel</span>
<span class="comment">%             with the screen. The output resolution is approximate and</span>
<span class="comment">%             should not be relied upon. Anti-aliasing can have adverse</span>
<span class="comment">%             effects on image quality (disable with the -a1 option).</span>
<span class="comment">%   -a1, -a2, -a3, -a4 - option indicating the amount of anti-aliasing to</span>
<span class="comment">%                        use for bitmap outputs. '-a1' means no anti-</span>
<span class="comment">%                        aliasing; '-a4' is the maximum amount (default).</span>
<span class="comment">%   -&lt;renderer&gt; - option to force a particular renderer (painters, opengl</span>
<span class="comment">%                 or zbuffer) to be used over the default: opengl for</span>
<span class="comment">%                 bitmaps; painters for vector formats.</span>
<span class="comment">%   -&lt;colorspace&gt; - option indicating which colorspace color figures should</span>
<span class="comment">%                   be saved in: RGB (default), CMYK or gray. CMYK is only</span>
<span class="comment">%                   supported in pdf, eps and tiff output.</span>
<span class="comment">%   -q&lt;val&gt; - option to vary bitmap image quality (in pdf, eps and jpg</span>
<span class="comment">%             files only).  Larger val, in the range 0-100, gives higher</span>
<span class="comment">%             quality/lower compression. val &gt; 100 gives lossless</span>
<span class="comment">%             compression. Default: '-q95' for jpg, ghostscript prepress</span>
<span class="comment">%             default for pdf &amp; eps. Note: lossless compression can</span>
<span class="comment">%             sometimes give a smaller file size than the default lossy</span>
<span class="comment">%             compression, depending on the type of images.</span>
<span class="comment">%   -append - option indicating that if the file (pdfs only) already</span>
<span class="comment">%             exists, the figure is to be appended as a new page, instead</span>
<span class="comment">%             of being overwritten (default).</span>
<span class="comment">%   -bookmark - option to indicate that a bookmark with the name of the</span>
<span class="comment">%               figure is to be created in the output file (pdf only).</span>
<span class="comment">%   handle - The handle of the figure, axes or uipanels (can be an array of</span>
<span class="comment">%            handles, but the objects must be in the same figure) to be</span>
<span class="comment">%            saved. Default: gcf.</span>
<span class="comment">%</span>
<span class="comment">%OUT:</span>
<span class="comment">%   im - MxNxC uint8 image array of the figure.</span>
<span class="comment">%   alpha - MxN single array of alphamatte values in range [0,1], for the</span>
<span class="comment">%           case when the background is transparent.</span>
<span class="comment">%</span>
<span class="comment">%   Some helpful examples and tips can be found at:</span>
<span class="comment">%      http://sites.google.com/site/oliverwoodford/software/export_fig</span>
<span class="comment">%</span>
<span class="comment">%   See also PRINT, SAVEAS.</span>

<span class="comment">% Copyright (C) Oliver Woodford 2008-2012</span>

<span class="comment">% The idea of using ghostscript is inspired by Peder Axensten's SAVEFIG</span>
<span class="comment">% (fex id: 10889) which is itself inspired by EPS2PDF (fex id: 5782).</span>
<span class="comment">% The idea for using pdftops came from the MATLAB newsgroup (id: 168171).</span>
<span class="comment">% The idea of editing the EPS file to change line styles comes from Jiro</span>
<span class="comment">% Doke's FIXPSLINESTYLE (fex id: 17928).</span>
<span class="comment">% The idea of changing dash length with line width came from comments on</span>
<span class="comment">% fex id: 5743, but the implementation is mine :)</span>
<span class="comment">% The idea of anti-aliasing bitmaps came from Anders Brun's MYAA (fex id:</span>
<span class="comment">% 20979).</span>
<span class="comment">% The idea of appending figures in pdfs came from Matt C in comments on the</span>
<span class="comment">% FEX (id: 23629)</span>

<span class="comment">% Thanks to Roland Martin for pointing out the colour MATLAB</span>
<span class="comment">% bug/feature with colorbar axes and transparent backgrounds.</span>
<span class="comment">% Thanks also to Andrew Matthews for describing a bug to do with the figure</span>
<span class="comment">% size changing in -nodisplay mode. I couldn't reproduce it, but included a</span>
<span class="comment">% fix anyway.</span>
<span class="comment">% Thanks to Tammy Threadgill for reporting a bug where an axes is not</span>
<span class="comment">% isolated from gui objects.</span>

<span class="comment">% 23/02/12: Ensure that axes limits don't change during printing</span>
<span class="comment">% 14/03/12: Fix bug in fixing the axes limits (thanks to Tobias Lamour for</span>
<span class="comment">%           reporting it).</span>
<span class="comment">% 02/05/12: Incorporate patch of Petr Nechaev (many thanks), enabling</span>
<span class="comment">%           bookmarking of figures in pdf files.</span>
<span class="comment">% 09/05/12: Incorporate patch of Arcelia Arrieta (many thanks), to keep</span>
<span class="comment">%           tick marks fixed.</span>
<span class="comment">% 12/12/12: Add support for isolating uipanels. Thanks to michael for</span>
<span class="comment">%           suggesting it.</span>

<span class="keyword">function</span> [im, alpha] = export_fig(varargin)
<span class="comment">% Make sure the figure is rendered correctly _now_ so that properties like</span>
<span class="comment">% axes limits are up-to-date.</span>
drawnow;
<span class="comment">% Parse the input arguments</span>
[fig, options] = parse_args(nargout, varargin{:});
<span class="comment">% Isolate the subplot, if it is one</span>
cls = all(ismember(get(fig, <span class="string">'Type'</span>), {<span class="string">'axes'</span>, <span class="string">'uipanel'</span>}));
<span class="keyword">if</span> cls
    <span class="comment">% Given handles of one or more axes, so isolate them from the rest</span>
    fig = isolate_axes(fig);
<span class="keyword">else</span>
    <span class="comment">% Check we have a figure</span>
    <span class="keyword">if</span> ~isequal(get(fig, <span class="string">'Type'</span>), <span class="string">'figure'</span>);
        error(<span class="string">'Handle must be that of a figure, axes or uipanel'</span>);
    <span class="keyword">end</span>
    <span class="comment">% Get the old InvertHardcopy mode</span>
    old_mode = get(fig, <span class="string">'InvertHardcopy'</span>);
<span class="keyword">end</span>
<span class="comment">% Hack the font units where necessary (due to a font rendering bug in</span>
<span class="comment">% print?). This may not work perfectly in all cases. Also it can change the</span>
<span class="comment">% figure layout if reverted, so use a copy.</span>
magnify = options.magnify * options.aa_factor;
<span class="keyword">if</span> isbitmap(options) &amp;&amp; magnify ~= 1
    fontu = findobj(fig, <span class="string">'FontUnits'</span>, <span class="string">'normalized'</span>);
    <span class="keyword">if</span> ~isempty(fontu)
        <span class="comment">% Some normalized font units found</span>
        <span class="keyword">if</span> ~cls
            fig = copyfig(fig);
            set(fig, <span class="string">'Visible'</span>, <span class="string">'off'</span>);
            fontu = findobj(fig, <span class="string">'FontUnits'</span>, <span class="string">'normalized'</span>);
            cls = true;
        <span class="keyword">end</span>
        set(fontu, <span class="string">'FontUnits'</span>, <span class="string">'points'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% MATLAB "feature": axes limits and tick marks can change when printing</span>
Hlims = findall(fig, <span class="string">'Type'</span>, <span class="string">'axes'</span>);
<span class="keyword">if</span> ~cls
    <span class="comment">% Record the old axes limit and tick modes</span>
    Xlims = make_cell(get(Hlims, <span class="string">'XLimMode'</span>));
    Ylims = make_cell(get(Hlims, <span class="string">'YLimMode'</span>));
    Zlims = make_cell(get(Hlims, <span class="string">'ZLimMode'</span>));
    Xtick = make_cell(get(Hlims, <span class="string">'XTickMode'</span>));
    Ytick = make_cell(get(Hlims, <span class="string">'YTickMode'</span>));
    Ztick = make_cell(get(Hlims, <span class="string">'ZTickMode'</span>));
<span class="keyword">end</span>
<span class="comment">% Set all axes limit and tick modes to manual, so the limits and ticks can't change</span>
set(Hlims, <span class="string">'XLimMode'</span>, <span class="string">'manual'</span>, <span class="string">'YLimMode'</span>, <span class="string">'manual'</span>, <span class="string">'ZLimMode'</span>, <span class="string">'manual'</span>, <span class="string">'XTickMode'</span>, <span class="string">'manual'</span>, <span class="string">'YTickMode'</span>, <span class="string">'manual'</span>, <span class="string">'ZTickMode'</span>, <span class="string">'manual'</span>);
<span class="comment">% Set to print exactly what is there</span>
set(fig, <span class="string">'InvertHardcopy'</span>, <span class="string">'off'</span>);
<span class="comment">% Set the renderer</span>
<span class="keyword">switch</span> options.renderer
    <span class="keyword">case</span> 1
        renderer = <span class="string">'-opengl'</span>;
    <span class="keyword">case</span> 2
        renderer = <span class="string">'-zbuffer'</span>;
    <span class="keyword">case</span> 3
        renderer = <span class="string">'-painters'</span>;
    <span class="keyword">otherwise</span>
        renderer = <span class="string">'-opengl'</span>; <span class="comment">% Default for bitmaps</span>
<span class="keyword">end</span>
<span class="comment">% Do the bitmap formats first</span>
<span class="keyword">if</span> isbitmap(options)
    <span class="comment">% Get the background colour</span>
    <span class="keyword">if</span> options.transparent &amp;&amp; (options.png || options.alpha)
        <span class="comment">% Get out an alpha channel</span>
        <span class="comment">% MATLAB "feature": black colorbar axes can change to white and vice versa!</span>
        hCB = findobj(fig, <span class="string">'Type'</span>, <span class="string">'axes'</span>, <span class="string">'Tag'</span>, <span class="string">'Colorbar'</span>);
        <span class="keyword">if</span> isempty(hCB)
            yCol = [];
            xCol = [];
        <span class="keyword">else</span>
            yCol = get(hCB, <span class="string">'YColor'</span>);
            xCol = get(hCB, <span class="string">'XColor'</span>);
            <span class="keyword">if</span> iscell(yCol)
                yCol = cell2mat(yCol);
                xCol = cell2mat(xCol);
            <span class="keyword">end</span>
            yCol = sum(yCol, 2);
            xCol = sum(xCol, 2);
        <span class="keyword">end</span>
        <span class="comment">% MATLAB "feature": apparently figure size can change when changing</span>
        <span class="comment">% colour in -nodisplay mode</span>
        pos = get(fig, <span class="string">'Position'</span>);
        <span class="comment">% Set the background colour to black, and set size in case it was</span>
        <span class="comment">% changed internally</span>
        tcol = get(fig, <span class="string">'Color'</span>);
        set(fig, <span class="string">'Color'</span>, <span class="string">'k'</span>, <span class="string">'Position'</span>, pos);
        <span class="comment">% Correct the colorbar axes colours</span>
        set(hCB(yCol==0), <span class="string">'YColor'</span>, [0 0 0]);
        set(hCB(xCol==0), <span class="string">'XColor'</span>, [0 0 0]);
        <span class="comment">% Print large version to array</span>
        B = print2array(fig, magnify, renderer);
        <span class="comment">% Downscale the image</span>
        B = downsize(single(B), options.aa_factor);
        <span class="comment">% Set background to white (and set size)</span>
        set(fig, <span class="string">'Color'</span>, <span class="string">'w'</span>, <span class="string">'Position'</span>, pos);
        <span class="comment">% Correct the colorbar axes colours</span>
        set(hCB(yCol==3), <span class="string">'YColor'</span>, [1 1 1]);
        set(hCB(xCol==3), <span class="string">'XColor'</span>, [1 1 1]);
        <span class="comment">% Print large version to array</span>
        A = print2array(fig, magnify, renderer);
        <span class="comment">% Downscale the image</span>
        A = downsize(single(A), options.aa_factor);
        <span class="comment">% Set the background colour (and size) back to normal</span>
        set(fig, <span class="string">'Color'</span>, tcol, <span class="string">'Position'</span>, pos);
        <span class="comment">% Compute the alpha map</span>
        alpha = round(sum(B - A, 3)) / (255 * 3) + 1;
        A = alpha;
        A(A==0) = 1;
        A = B ./ A(:,:,[1 1 1]);
        clear <span class="string">B</span>
        <span class="comment">% Convert to greyscale</span>
        <span class="keyword">if</span> options.colourspace == 2
            A = rgb2grey(A);
        <span class="keyword">end</span>
        A = uint8(A);
        <span class="comment">% Crop the background</span>
        <span class="keyword">if</span> options.crop
            [alpha, v] = crop_background(alpha, 0);
            A = A(v(1):v(2),v(3):v(4),:);
        <span class="keyword">end</span>
        <span class="keyword">if</span> options.png
            <span class="comment">% Compute the resolution</span>
            res = options.magnify * get(0, <span class="string">'ScreenPixelsPerInch'</span>) / 25.4e-3;
            <span class="comment">% Save the png</span>
            imwrite(A, [options.name <span class="string">'.png'</span>], <span class="string">'Alpha'</span>, double(alpha), <span class="string">'ResolutionUnit'</span>, <span class="string">'meter'</span>, <span class="string">'XResolution'</span>, res, <span class="string">'YResolution'</span>, res);
            <span class="comment">% Clear the png bit</span>
            options.png = false;
        <span class="keyword">end</span>
        <span class="comment">% Return only one channel for greyscale</span>
        <span class="keyword">if</span> isbitmap(options)
            A = check_greyscale(A);
        <span class="keyword">end</span>
        <span class="keyword">if</span> options.alpha
            <span class="comment">% Store the image</span>
            im = A;
            <span class="comment">% Clear the alpha bit</span>
            options.alpha = false;
        <span class="keyword">end</span>
        <span class="comment">% Get the non-alpha image</span>
        <span class="keyword">if</span> isbitmap(options)
            alph = alpha(:,:,ones(1, size(A, 3)));
            A = uint8(single(A) .* alph + 255 * (1 - alph));
            clear <span class="string">alph</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> options.im
            <span class="comment">% Store the new image</span>
            im = A;
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="comment">% Print large version to array</span>
        <span class="keyword">if</span> options.transparent
            <span class="comment">% MATLAB "feature": apparently figure size can change when changing</span>
            <span class="comment">% colour in -nodisplay mode</span>
            pos = get(fig, <span class="string">'Position'</span>);
            tcol = get(fig, <span class="string">'Color'</span>);
            set(fig, <span class="string">'Color'</span>, <span class="string">'w'</span>, <span class="string">'Position'</span>, pos);
            A = print2array(fig, magnify, renderer);
            set(fig, <span class="string">'Color'</span>, tcol, <span class="string">'Position'</span>, pos);
            tcol = 255;
        <span class="keyword">else</span>
            [A, tcol] = print2array(fig, magnify, renderer);
        <span class="keyword">end</span>
        <span class="comment">% Crop the background</span>
        <span class="keyword">if</span> options.crop
            A = crop_background(A, tcol);
        <span class="keyword">end</span>
        <span class="comment">% Downscale the image</span>
        A = downsize(A, options.aa_factor);
        <span class="keyword">if</span> options.colourspace == 2
            <span class="comment">% Convert to greyscale</span>
            A = rgb2grey(A);
        <span class="keyword">else</span>
            <span class="comment">% Return only one channel for greyscale</span>
            A = check_greyscale(A);
        <span class="keyword">end</span>
        <span class="comment">% Outputs</span>
        <span class="keyword">if</span> options.im
            im = A;
        <span class="keyword">end</span>
        <span class="keyword">if</span> options.alpha
            im = A;
            alpha = zeros(size(A, 1), size(A, 2), <span class="string">'single'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% Save the images</span>
    <span class="keyword">if</span> options.png
        res = options.magnify * get(0, <span class="string">'ScreenPixelsPerInch'</span>) / 25.4e-3;
        imwrite(A, [options.name <span class="string">'.png'</span>], <span class="string">'ResolutionUnit'</span>, <span class="string">'meter'</span>, <span class="string">'XResolution'</span>, res, <span class="string">'YResolution'</span>, res);
    <span class="keyword">end</span>
    <span class="keyword">if</span> options.bmp
        imwrite(A, [options.name <span class="string">'.bmp'</span>]);
    <span class="keyword">end</span>
    <span class="comment">% Save jpeg with given quality</span>
    <span class="keyword">if</span> options.jpg
        quality = options.quality;
        <span class="keyword">if</span> isempty(quality)
            quality = 95;
        <span class="keyword">end</span>
        <span class="keyword">if</span> quality &gt; 100
            imwrite(A, [options.name <span class="string">'.jpg'</span>], <span class="string">'Mode'</span>, <span class="string">'lossless'</span>);
        <span class="keyword">else</span>
            imwrite(A, [options.name <span class="string">'.jpg'</span>], <span class="string">'Quality'</span>, quality);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% Save tif images in cmyk if wanted (and possible)</span>
    <span class="keyword">if</span> options.tif
        <span class="keyword">if</span> options.colourspace == 1 &amp;&amp; size(A, 3) == 3
            A = double(255 - A);
            K = min(A, [], 3);
            K_ = 255 ./ max(255 - K, 1);
            C = (A(:,:,1) - K) .* K_;
            M = (A(:,:,2) - K) .* K_;
            Y = (A(:,:,3) - K) .* K_;
            A = uint8(cat(3, C, M, Y, K));
            clear <span class="string">C</span> <span class="string">M</span> <span class="string">Y</span> <span class="string">K</span> <span class="string">K_</span>
        <span class="keyword">end</span>
        append_mode = {<span class="string">'overwrite'</span>, <span class="string">'append'</span>};
        imwrite(A, [options.name <span class="string">'.tif'</span>], <span class="string">'Resolution'</span>, options.magnify*get(0, <span class="string">'ScreenPixelsPerInch'</span>), <span class="string">'WriteMode'</span>, append_mode{options.append+1});
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Now do the vector formats</span>
<span class="keyword">if</span> isvector(options)
    <span class="comment">% Set the default renderer to painters</span>
    <span class="keyword">if</span> ~options.renderer
        renderer = <span class="string">'-painters'</span>;
    <span class="keyword">end</span>
    <span class="comment">% Generate some filenames</span>
    tmp_nam = [tempname <span class="string">'.eps'</span>];
    <span class="keyword">if</span> options.pdf
        pdf_nam = [options.name <span class="string">'.pdf'</span>];
    <span class="keyword">else</span>
        pdf_nam = [tempname <span class="string">'.pdf'</span>];
    <span class="keyword">end</span>
    <span class="comment">% Generate the options for print</span>
    p2eArgs = {renderer};
    <span class="keyword">if</span> options.colourspace == 1
        p2eArgs = [p2eArgs {<span class="string">'-cmyk'</span>}];
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~options.crop
        p2eArgs = [p2eArgs {<span class="string">'-loose'</span>}];
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        <span class="comment">% Generate an eps</span>
        print2eps(tmp_nam, fig, p2eArgs{:});
        <span class="comment">% Remove the background, if desired</span>
        <span class="keyword">if</span> options.transparent &amp;&amp; ~isequal(get(fig, <span class="string">'Color'</span>), <span class="string">'none'</span>)
            eps_remove_background(tmp_nam);
        <span class="keyword">end</span>
        <span class="comment">% Add a bookmark to the PDF if desired</span>
        <span class="keyword">if</span> options.bookmark
            fig_nam = get(fig, <span class="string">'Name'</span>);
            <span class="keyword">if</span> isempty(fig_nam)
                warning(<span class="string">'export_fig:EmptyBookmark'</span>, <span class="string">'Bookmark requested for figure with no name. Bookmark will be empty.'</span>);
            <span class="keyword">end</span>
            add_bookmark(tmp_nam, fig_nam);
        <span class="keyword">end</span>
        <span class="comment">% Generate a pdf</span>
        eps2pdf(tmp_nam, pdf_nam, 1, options.append, options.colourspace==2, options.quality);
    <span class="keyword">catch</span> ex
        <span class="comment">% Delete the eps</span>
        delete(tmp_nam);
        rethrow(ex);
    <span class="keyword">end</span>
    <span class="comment">% Delete the eps</span>
    delete(tmp_nam);
    <span class="keyword">if</span> options.eps
        <span class="keyword">try</span>
            <span class="comment">% Generate an eps from the pdf</span>
            pdf2eps(pdf_nam, [options.name <span class="string">'.eps'</span>]);
        <span class="keyword">catch</span> ex
            <span class="keyword">if</span> ~options.pdf
                <span class="comment">% Delete the pdf</span>
                delete(pdf_nam);
            <span class="keyword">end</span>
            rethrow(ex);
        <span class="keyword">end</span>
        <span class="keyword">if</span> ~options.pdf
            <span class="comment">% Delete the pdf</span>
            delete(pdf_nam);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> cls
    <span class="comment">% Close the created figure</span>
    close(fig);
<span class="keyword">else</span>
    <span class="comment">% Reset the hardcopy mode</span>
    set(fig, <span class="string">'InvertHardcopy'</span>, old_mode);
    <span class="comment">% Reset the axes limit and tick modes</span>
    <span class="keyword">for</span> a = 1:numel(Hlims)
        set(Hlims(a), <span class="string">'XLimMode'</span>, Xlims{a}, <span class="string">'YLimMode'</span>, Ylims{a}, <span class="string">'ZLimMode'</span>, Zlims{a}, <span class="string">'XTickMode'</span>, Xtick{a}, <span class="string">'YTickMode'</span>, Ytick{a}, <span class="string">'ZTickMode'</span>, Ztick{a});
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">return</span>

<span class="keyword">function</span> [fig, options] = parse_args(nout, varargin)
<span class="comment">% Parse the input arguments</span>
<span class="comment">% Set the defaults</span>
fig = get(0, <span class="string">'CurrentFigure'</span>);
options = struct(<span class="string">'name'</span>, <span class="string">'export_fig_out'</span>, <span class="keyword">...</span>
                 <span class="string">'crop'</span>, true, <span class="keyword">...</span>
                 <span class="string">'transparent'</span>, false, <span class="keyword">...</span>
                 <span class="string">'renderer'</span>, 0, <span class="keyword">...</span><span class="comment"> % 0: default, 1: OpenGL, 2: ZBuffer, 3: Painters</span>
                 <span class="string">'pdf'</span>, false, <span class="keyword">...</span>
                 <span class="string">'eps'</span>, false, <span class="keyword">...</span>
                 <span class="string">'png'</span>, false, <span class="keyword">...</span>
                 <span class="string">'tif'</span>, false, <span class="keyword">...</span>
                 <span class="string">'jpg'</span>, false, <span class="keyword">...</span>
                 <span class="string">'bmp'</span>, false, <span class="keyword">...</span>
                 <span class="string">'colourspace'</span>, 0, <span class="keyword">...</span><span class="comment"> % 0: RGB/gray, 1: CMYK, 2: gray</span>
                 <span class="string">'append'</span>, false, <span class="keyword">...</span>
                 <span class="string">'im'</span>, nout == 1, <span class="keyword">...</span>
                 <span class="string">'alpha'</span>, nout == 2, <span class="keyword">...</span>
                 <span class="string">'aa_factor'</span>, 3, <span class="keyword">...</span>
                 <span class="string">'magnify'</span>, 1, <span class="keyword">...</span>
                 <span class="string">'bookmark'</span>, false, <span class="keyword">...</span>
                 <span class="string">'quality'</span>, []);
native = false; <span class="comment">% Set resolution to native of an image</span>

<span class="comment">% Go through the other arguments</span>
<span class="keyword">for</span> a = 1:nargin-1
    <span class="keyword">if</span> all(ishandle(varargin{a}))
        fig = varargin{a};
    <span class="keyword">elseif</span> ischar(varargin{a}) &amp;&amp; ~isempty(varargin{a})
        <span class="keyword">if</span> varargin{a}(1) == <span class="string">'-'</span>
            <span class="keyword">switch</span> lower(varargin{a}(2:end))
                <span class="keyword">case</span> <span class="string">'nocrop'</span>
                    options.crop = false;
                <span class="keyword">case</span> {<span class="string">'trans'</span>, <span class="string">'transparent'</span>}
                    options.transparent = true;
                <span class="keyword">case</span> <span class="string">'opengl'</span>
                    options.renderer = 1;
                <span class="keyword">case</span> <span class="string">'zbuffer'</span>
                    options.renderer = 2;
                <span class="keyword">case</span> <span class="string">'painters'</span>
                    options.renderer = 3;
                <span class="keyword">case</span> <span class="string">'pdf'</span>
                    options.pdf = true;
                <span class="keyword">case</span> <span class="string">'eps'</span>
                    options.eps = true;
                <span class="keyword">case</span> <span class="string">'png'</span>
                    options.png = true;
                <span class="keyword">case</span> {<span class="string">'tif'</span>, <span class="string">'tiff'</span>}
                    options.tif = true;
                <span class="keyword">case</span> {<span class="string">'jpg'</span>, <span class="string">'jpeg'</span>}
                    options.jpg = true;
                <span class="keyword">case</span> <span class="string">'bmp'</span>
                    options.bmp = true;
                <span class="keyword">case</span> <span class="string">'rgb'</span>
                    options.colourspace = 0;
                <span class="keyword">case</span> <span class="string">'cmyk'</span>
                    options.colourspace = 1;
                <span class="keyword">case</span> {<span class="string">'gray'</span>, <span class="string">'grey'</span>}
                    options.colourspace = 2;
                <span class="keyword">case</span> {<span class="string">'a1'</span>, <span class="string">'a2'</span>, <span class="string">'a3'</span>, <span class="string">'a4'</span>}
                    options.aa_factor = str2double(varargin{a}(3));
                <span class="keyword">case</span> <span class="string">'append'</span>
                    options.append = true;
                <span class="keyword">case</span> <span class="string">'bookmark'</span>
                    options.bookmark = true;
                <span class="keyword">case</span> <span class="string">'native'</span>
                    native = true;
                <span class="keyword">otherwise</span>
                    val = str2double(regexp(varargin{a}, <span class="string">'(?&lt;=-(m|M|r|R|q|Q))(\d*\.)?\d+(e-?\d+)?'</span>, <span class="string">'match'</span>));
                    <span class="keyword">if</span> ~isscalar(val)
                        error(<span class="string">'option %s not recognised'</span>, varargin{a});
                    <span class="keyword">end</span>
                    <span class="keyword">switch</span> lower(varargin{a}(2))
                        <span class="keyword">case</span> <span class="string">'m'</span>
                            options.magnify = val;
                        <span class="keyword">case</span> <span class="string">'r'</span>
                            options.magnify = val ./ get(0, <span class="string">'ScreenPixelsPerInch'</span>);
                        <span class="keyword">case</span> <span class="string">'q'</span>
                            options.quality = max(val, 0);
                    <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            [p, options.name, ext] = fileparts(varargin{a});
            <span class="keyword">if</span> ~isempty(p)
                options.name = [p filesep options.name];
            <span class="keyword">end</span>
            <span class="keyword">switch</span> lower(ext)
                <span class="keyword">case</span> {<span class="string">'.tif'</span>, <span class="string">'.tiff'</span>}
                    options.tif = true;
                <span class="keyword">case</span> {<span class="string">'.jpg'</span>, <span class="string">'.jpeg'</span>}
                    options.jpg = true;
                <span class="keyword">case</span> <span class="string">'.png'</span>
                    options.png = true;
                <span class="keyword">case</span> <span class="string">'.bmp'</span>
                    options.bmp = true;
                <span class="keyword">case</span> <span class="string">'.eps'</span>
                    options.eps = true;
                <span class="keyword">case</span> <span class="string">'.pdf'</span>
                    options.pdf = true;
                <span class="keyword">otherwise</span>
                    options.name = varargin{a};
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Check we have a figure handle</span>
<span class="keyword">if</span> isempty(fig)
    error(<span class="string">'No figure found'</span>);
<span class="keyword">end</span>

<span class="comment">% Set the default format</span>
<span class="keyword">if</span> ~isvector(options) &amp;&amp; ~isbitmap(options)
    options.png = true;
<span class="keyword">end</span>

<span class="comment">% Check whether transparent background is wanted (old way)</span>
<span class="keyword">if</span> isequal(get(ancestor(fig, <span class="string">'figure'</span>), <span class="string">'Color'</span>), <span class="string">'none'</span>)
    options.transparent = true;
<span class="keyword">end</span>

<span class="comment">% If requested, set the resolution to the native vertical resolution of the</span>
<span class="comment">% first suitable image found</span>
<span class="keyword">if</span> native &amp;&amp; isbitmap(options)
    <span class="comment">% Find a suitable image</span>
    list = findobj(fig, <span class="string">'Type'</span>, <span class="string">'image'</span>, <span class="string">'Tag'</span>, <span class="string">'export_fig_native'</span>);
    <span class="keyword">if</span> isempty(list)
        list = findobj(fig, <span class="string">'Type'</span>, <span class="string">'image'</span>, <span class="string">'Visible'</span>, <span class="string">'on'</span>);
    <span class="keyword">end</span>
    <span class="keyword">for</span> hIm = list(:)'
        <span class="comment">% Check height is &gt;= 2</span>
        height = size(get(hIm, <span class="string">'CData'</span>), 1);
        <span class="keyword">if</span> height &lt; 2
            <span class="keyword">continue</span>
        <span class="keyword">end</span>
        <span class="comment">% Account for the image filling only part of the axes, or vice</span>
        <span class="comment">% versa</span>
        yl = get(hIm, <span class="string">'YData'</span>);
        <span class="keyword">if</span> isscalar(yl)
            yl = [yl(1)-0.5 yl(1)+height+0.5];
        <span class="keyword">else</span>
            <span class="keyword">if</span> ~diff(yl)
                <span class="keyword">continue</span>
            <span class="keyword">end</span>
            yl = yl + [-0.5 0.5] * (diff(yl) / (height - 1));
        <span class="keyword">end</span>
        hAx = get(hIm, <span class="string">'Parent'</span>);
        yl2 = get(hAx, <span class="string">'YLim'</span>);
        <span class="comment">% Find the pixel height of the axes</span>
        oldUnits = get(hAx, <span class="string">'Units'</span>);
        set(hAx, <span class="string">'Units'</span>, <span class="string">'pixels'</span>);
        pos = get(hAx, <span class="string">'Position'</span>);
        set(hAx, <span class="string">'Units'</span>, oldUnits);
        <span class="keyword">if</span> ~pos(4)
            <span class="keyword">continue</span>
        <span class="keyword">end</span>
        <span class="comment">% Found a suitable image</span>
        <span class="comment">% Account for stretch-to-fill being disabled</span>
        pbar = get(hAx, <span class="string">'PlotBoxAspectRatio'</span>);
        pos = min(pos(4), pbar(2)*pos(3)/pbar(1));
        <span class="comment">% Set the magnification to give native resolution</span>
        options.magnify = (height * diff(yl2)) / (pos * diff(yl));
        <span class="keyword">break</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">return</span>

<span class="keyword">function</span> A = downsize(A, factor)
<span class="comment">% Downsample an image</span>
<span class="keyword">if</span> factor == 1
    <span class="comment">% Nothing to do</span>
    <span class="keyword">return</span>
<span class="keyword">end</span>
<span class="keyword">try</span>
    <span class="comment">% Faster, but requires image processing toolbox</span>
    A = imresize(A, 1/factor, <span class="string">'bilinear'</span>);
<span class="keyword">catch</span>
    <span class="comment">% No image processing toolbox - resize manually</span>
    <span class="comment">% Lowpass filter - use Gaussian as is separable, so faster</span>
    <span class="comment">% Compute the 1d Gaussian filter</span>
    filt = (-factor-1:factor+1) / (factor * 0.6);
    filt = exp(-filt .* filt);
    <span class="comment">% Normalize the filter</span>
    filt = single(filt / sum(filt));
    <span class="comment">% Filter the image</span>
    padding = floor(numel(filt) / 2);
    <span class="keyword">for</span> a = 1:size(A, 3)
        A(:,:,a) = conv2(filt, filt', single(A([ones(1, padding) 1:end repmat(end, 1, padding)],[ones(1, padding) 1:end repmat(end, 1, padding)],a)), <span class="string">'valid'</span>);
    <span class="keyword">end</span>
    <span class="comment">% Subsample</span>
    A = A(1+floor(mod(end-1, factor)/2):factor:end,1+floor(mod(end-1, factor)/2):factor:end,:);
<span class="keyword">end</span>
<span class="keyword">return</span>

<span class="keyword">function</span> A = rgb2grey(A)
A = cast(reshape(reshape(single(A), [], 3) * single([0.299; 0.587; 0.114]), size(A, 1), size(A, 2)), class(A));
<span class="keyword">return</span>

<span class="keyword">function</span> A = check_greyscale(A)
<span class="comment">% Check if the image is greyscale</span>
<span class="keyword">if</span> size(A, 3) == 3 &amp;&amp; <span class="keyword">...</span>
        all(reshape(A(:,:,1) == A(:,:,2), [], 1)) &amp;&amp; <span class="keyword">...</span>
        all(reshape(A(:,:,2) == A(:,:,3), [], 1))
    A = A(:,:,1); <span class="comment">% Save only one channel for 8-bit output</span>
<span class="keyword">end</span>
<span class="keyword">return</span>

<span class="keyword">function</span> [A, v] = crop_background(A, bcol)
<span class="comment">% Map the foreground pixels</span>
[h, w, c] = size(A);
<span class="keyword">if</span> isscalar(bcol) &amp;&amp; c &gt; 1
    bcol = bcol(ones(1, c));
<span class="keyword">end</span>
bail = false;
<span class="keyword">for</span> l = 1:w
    <span class="keyword">for</span> a = 1:c
        <span class="keyword">if</span> ~all(A(:,l,a) == bcol(a))
            bail = true;
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> bail
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
bail = false;
<span class="keyword">for</span> r = w:-1:l
    <span class="keyword">for</span> a = 1:c
        <span class="keyword">if</span> ~all(A(:,r,a) == bcol(a))
            bail = true;
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> bail
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
bail = false;
<span class="keyword">for</span> t = 1:h
    <span class="keyword">for</span> a = 1:c
        <span class="keyword">if</span> ~all(A(t,:,a) == bcol(a))
            bail = true;
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> bail
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
bail = false;
<span class="keyword">for</span> b = h:-1:t
    <span class="keyword">for</span> a = 1:c
        <span class="keyword">if</span> ~all(A(b,:,a) == bcol(a))
            bail = true;
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> bail
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Crop the background, leaving one boundary pixel to avoid bleeding on</span>
<span class="comment">% resize</span>
v = [max(t-1, 1) min(b+1, h) max(l-1, 1) min(r+1, w)];
A = A(v(1):v(2),v(3):v(4),:);
<span class="keyword">return</span>

<span class="keyword">function</span> eps_remove_background(fname)
<span class="comment">% Remove the background of an eps file</span>
<span class="comment">% Open the file</span>
fh = fopen(fname, <span class="string">'r+'</span>);
<span class="keyword">if</span> fh == -1
    error(<span class="string">'Not able to open file %s.'</span>, fname);
<span class="keyword">end</span>
<span class="comment">% Read the file line by line</span>
<span class="keyword">while</span> true
    <span class="comment">% Get the next line</span>
    l = fgets(fh);
    <span class="keyword">if</span> isequal(l, -1)
        <span class="keyword">break</span>; <span class="comment">% Quit, no rectangle found</span>
    <span class="keyword">end</span>
    <span class="comment">% Check if the line contains the background rectangle</span>
    <span class="keyword">if</span> isequal(regexp(l, <span class="string">' *0 +0 +\d+ +\d+ +rf *[\n\r]+'</span>, <span class="string">'start'</span>), 1)
        <span class="comment">% Set the line to whitespace and quit</span>
        l(1:regexp(l, <span class="string">'[\n\r]'</span>, <span class="string">'start'</span>, <span class="string">'once'</span>)-1) = <span class="string">' '</span>;
        fseek(fh, -numel(l), 0);
        fprintf(fh, l);
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Close the file</span>
fclose(fh);
<span class="keyword">return</span>

<span class="keyword">function</span> b = isvector(options)
b = options.pdf || options.eps;
<span class="keyword">return</span>

<span class="keyword">function</span> b = isbitmap(options)
b = options.png || options.tif || options.jpg || options.bmp || options.im || options.alpha;
<span class="keyword">return</span>

<span class="comment">% Helper function</span>
<span class="keyword">function</span> A = make_cell(A)
<span class="keyword">if</span> ~iscell(A)
    A = {A};
<span class="keyword">end</span>
<span class="keyword">return</span>

<span class="keyword">function</span> add_bookmark(fname, bookmark_text)
<span class="comment">% Adds a bookmark to the temporary EPS file after %%EndPageSetup</span>
<span class="comment">% Read in the file</span>
fh = fopen(fname, <span class="string">'r'</span>);
<span class="keyword">if</span> fh == -1
    error(<span class="string">'File %s not found.'</span>, fname);
<span class="keyword">end</span>
<span class="keyword">try</span>
    fstrm = fread(fh, <span class="string">'*char'</span>)';
<span class="keyword">catch</span> ex
    fclose(fh);
    rethrow(ex);
<span class="keyword">end</span>
fclose(fh);

<span class="comment">% Include standard pdfmark prolog to maximize compatibility</span>
fstrm = strrep(fstrm, <span class="string">'%%BeginProlog'</span>, sprintf(<span class="string">'%%%%BeginProlog\n/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse'</span>));
<span class="comment">% Add page bookmark</span>
fstrm = strrep(fstrm, <span class="string">'%%EndPageSetup'</span>, sprintf(<span class="string">'%%%%EndPageSetup\n[ /Title (%s) /OUT pdfmark'</span>,bookmark_text));

<span class="comment">% Write out the updated file</span>
fh = fopen(fname, <span class="string">'w'</span>);
<span class="keyword">if</span> fh == -1
    error(<span class="string">'Unable to open %s for writing.'</span>, fname);
<span class="keyword">end</span>
<span class="keyword">try</span>
    fwrite(fh, fstrm, <span class="string">'char*1'</span>);
<span class="keyword">catch</span> ex
    fclose(fh);
    rethrow(ex);
<span class="keyword">end</span>
fclose(fh);
<span class="keyword">return</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%EXPORT_FIG  Exports figures suitable for publication
%
% Examples:
%   im = export_fig
%   [im alpha] = export_fig
%   export_fig filename
%   export_fig filename -format1 -format2
%   export_fig ... -nocrop
%   export_fig ... -transparent
%   export_fig ... -native
%   export_fig ... -m<val>
%   export_fig ... -r<val>
%   export_fig ... -a<val>
%   export_fig ... -q<val>
%   export_fig ... -<renderer>
%   export_fig ... -<colorspace>
%   export_fig ... -append
%   export_fig ... -bookmark
%   export_fig(..., handle)
%
% This function saves a figure or single axes to one or more vector and/or
% bitmap file formats, and/or outputs a rasterized version to the
% workspace, with the following properties:
%   - Figure/axes reproduced as it appears on screen
%   - Cropped borders (optional)
%   - Embedded fonts (vector formats)
%   - Improved line and grid line styles
%   - Anti-aliased graphics (bitmap formats)
%   - Render images at native resolution (optional for bitmap formats)
%   - Transparent background supported (pdf, eps, png)
%   - Semi-transparent patch objects supported (png only)
%   - RGB, CMYK or grayscale output (CMYK only with pdf, eps, tiff)
%   - Variable image compression, including lossless (pdf, eps, jpg)
%   - Optionally append to file (pdf, tiff)
%   - Vector formats: pdf, eps
%   - Bitmap formats: png, tiff, jpg, bmp, export to workspace 
%   
% This function is especially suited to exporting figures for use in
% publications and presentations, because of the high quality and
% portability of media produced.
%
% Note that the background color and figure dimensions are reproduced
% (the latter approximately, and ignoring cropping & magnification) in the
% output file. For transparent background (and semi-transparent patch
% objects), use the -transparent option or set the figure 'Color' property
% to 'none'. To make axes transparent set the axes 'Color' property to
% 'none'. Pdf, eps and png are the only file formats to support a
% transparent background, whilst the png format alone supports transparency
% of patch objects.
%
% The choice of renderer (opengl, zbuffer or painters) has a large impact
% on the quality of output. Whilst the default value (opengl for bitmaps,
% painters for vector formats) generally gives good results, if you aren't
% satisfied then try another renderer.  Notes: 1) For vector formats (eps,
% pdf), only painters generates vector graphics. 2) For bitmaps, only
% opengl can render transparent patch objects correctly. 3) For bitmaps,
% only painters will correctly scale line dash and dot lengths when
% magnifying or anti-aliasing. 4) Fonts may be substitued with Courier when
% using painters.
%
% When exporting to vector format (pdf & eps) and bitmap format using the
% painters renderer, this function requires that ghostscript is installed
% on your system. You can download this from:
%   http://www.ghostscript.com
% When exporting to eps it additionally requires pdftops, from the Xpdf
% suite of functions. You can download this from:
%   http://www.foolabs.com/xpdf
%
%IN:
%   filename - string containing the name (optionally including full or
%              relative path) of the file the figure is to be saved as. If
%              a path is not specified, the figure is saved in the current
%              directory. If no name and no output arguments are specified,
%              the default name, 'export_fig_out', is used. If neither a
%              file extension nor a format are specified, a ".png" is added
%              and the figure saved in that format.
%   -format1, -format2, etc. - strings containing the extensions of the
%                              file formats the figure is to be saved as.
%                              Valid options are: '-pdf', '-eps', '-png',
%                              '-tif', '-jpg' and '-bmp'. All combinations
%                              of formats are valid.
%   -nocrop - option indicating that the borders of the output are not to
%             be cropped.
%   -transparent - option indicating that the figure background is to be
%                  made transparent (png, pdf and eps output only).
%   -m<val> - option where val indicates the factor to magnify the
%             on-screen figure dimensions by when generating bitmap
%             outputs. Default: '-m1'.
%   -r<val> - option val indicates the resolution (in pixels per inch) to
%             export bitmap outputs at, keeping the dimensions of the
%             on-screen figure. Default: sprintf('-r%g', get(0,
%             'ScreenPixelsPerInch')). Note that the -m and -r options
%             change the same property.
%   -native - option indicating that the output resolution (when outputting
%             a bitmap format) should be such that the vertical resolution
%             of the first suitable image found in the figure is at the
%             native resolution of that image. To specify a particular
%             image to use, give it the tag 'export_fig_native'. Notes:
%             This overrides any value set with the -m and -r options. It
%             also assumes that the image is displayed front-to-parallel
%             with the screen. The output resolution is approximate and
%             should not be relied upon. Anti-aliasing can have adverse
%             effects on image quality (disable with the -a1 option).
%   -a1, -a2, -a3, -a4 - option indicating the amount of anti-aliasing to
%                        use for bitmap outputs. '-a1' means no anti-
%                        aliasing; '-a4' is the maximum amount (default).
%   -<renderer> - option to force a particular renderer (painters, opengl
%                 or zbuffer) to be used over the default: opengl for
%                 bitmaps; painters for vector formats.
%   -<colorspace> - option indicating which colorspace color figures should
%                   be saved in: RGB (default), CMYK or gray. CMYK is only
%                   supported in pdf, eps and tiff output.
%   -q<val> - option to vary bitmap image quality (in pdf, eps and jpg
%             files only).  Larger val, in the range 0-100, gives higher
%             quality/lower compression. val > 100 gives lossless
%             compression. Default: '-q95' for jpg, ghostscript prepress
%             default for pdf & eps. Note: lossless compression can
%             sometimes give a smaller file size than the default lossy
%             compression, depending on the type of images.
%   -append - option indicating that if the file (pdfs only) already
%             exists, the figure is to be appended as a new page, instead
%             of being overwritten (default).
%   -bookmark - option to indicate that a bookmark with the name of the
%               figure is to be created in the output file (pdf only).
%   handle - The handle of the figure, axes or uipanels (can be an array of
%            handles, but the objects must be in the same figure) to be
%            saved. Default: gcf.
%
%OUT:
%   im - MxNxC uint8 image array of the figure.
%   alpha - MxN single array of alphamatte values in range [0,1], for the
%           case when the background is transparent.
%
%   Some helpful examples and tips can be found at:
%      http://sites.google.com/site/oliverwoodford/software/export_fig
%
%   See also PRINT, SAVEAS.

% Copyright (C) Oliver Woodford 2008-2012

% The idea of using ghostscript is inspired by Peder Axensten's SAVEFIG
% (fex id: 10889) which is itself inspired by EPS2PDF (fex id: 5782).
% The idea for using pdftops came from the MATLAB newsgroup (id: 168171).
% The idea of editing the EPS file to change line styles comes from Jiro
% Doke's FIXPSLINESTYLE (fex id: 17928).
% The idea of changing dash length with line width came from comments on
% fex id: 5743, but the implementation is mine :)
% The idea of anti-aliasing bitmaps came from Anders Brun's MYAA (fex id:
% 20979).
% The idea of appending figures in pdfs came from Matt C in comments on the
% FEX (id: 23629)

% Thanks to Roland Martin for pointing out the colour MATLAB
% bug/feature with colorbar axes and transparent backgrounds.
% Thanks also to Andrew Matthews for describing a bug to do with the figure
% size changing in -nodisplay mode. I couldn't reproduce it, but included a
% fix anyway.
% Thanks to Tammy Threadgill for reporting a bug where an axes is not
% isolated from gui objects.

% 23/02/12: Ensure that axes limits don't change during printing
% 14/03/12: Fix bug in fixing the axes limits (thanks to Tobias Lamour for
%           reporting it).
% 02/05/12: Incorporate patch of Petr Nechaev (many thanks), enabling
%           bookmarking of figures in pdf files.
% 09/05/12: Incorporate patch of Arcelia Arrieta (many thanks), to keep
%           tick marks fixed.
% 12/12/12: Add support for isolating uipanels. Thanks to michael for
%           suggesting it.

function [im, alpha] = export_fig(varargin)
% Make sure the figure is rendered correctly _now_ so that properties like
% axes limits are up-to-date.
drawnow;
% Parse the input arguments
[fig, options] = parse_args(nargout, varargin{:});
% Isolate the subplot, if it is one
cls = all(ismember(get(fig, 'Type'), {'axes', 'uipanel'}));
if cls
    % Given handles of one or more axes, so isolate them from the rest
    fig = isolate_axes(fig);
else
    % Check we have a figure
    if ~isequal(get(fig, 'Type'), 'figure');
        error('Handle must be that of a figure, axes or uipanel');
    end
    % Get the old InvertHardcopy mode
    old_mode = get(fig, 'InvertHardcopy');
end
% Hack the font units where necessary (due to a font rendering bug in
% print?). This may not work perfectly in all cases. Also it can change the
% figure layout if reverted, so use a copy.
magnify = options.magnify * options.aa_factor;
if isbitmap(options) && magnify ~= 1
    fontu = findobj(fig, 'FontUnits', 'normalized');
    if ~isempty(fontu)
        % Some normalized font units found
        if ~cls
            fig = copyfig(fig);
            set(fig, 'Visible', 'off');
            fontu = findobj(fig, 'FontUnits', 'normalized');
            cls = true;
        end
        set(fontu, 'FontUnits', 'points');
    end
end
% MATLAB "feature": axes limits and tick marks can change when printing
Hlims = findall(fig, 'Type', 'axes');
if ~cls
    % Record the old axes limit and tick modes
    Xlims = make_cell(get(Hlims, 'XLimMode'));
    Ylims = make_cell(get(Hlims, 'YLimMode'));
    Zlims = make_cell(get(Hlims, 'ZLimMode'));
    Xtick = make_cell(get(Hlims, 'XTickMode'));
    Ytick = make_cell(get(Hlims, 'YTickMode'));
    Ztick = make_cell(get(Hlims, 'ZTickMode'));
end
% Set all axes limit and tick modes to manual, so the limits and ticks can't change
set(Hlims, 'XLimMode', 'manual', 'YLimMode', 'manual', 'ZLimMode', 'manual', 'XTickMode', 'manual', 'YTickMode', 'manual', 'ZTickMode', 'manual');
% Set to print exactly what is there
set(fig, 'InvertHardcopy', 'off');
% Set the renderer
switch options.renderer
    case 1
        renderer = '-opengl';
    case 2
        renderer = '-zbuffer';
    case 3
        renderer = '-painters';
    otherwise
        renderer = '-opengl'; % Default for bitmaps
end
% Do the bitmap formats first
if isbitmap(options)
    % Get the background colour
    if options.transparent && (options.png || options.alpha)
        % Get out an alpha channel
        % MATLAB "feature": black colorbar axes can change to white and vice versa!
        hCB = findobj(fig, 'Type', 'axes', 'Tag', 'Colorbar');
        if isempty(hCB)
            yCol = [];
            xCol = [];
        else
            yCol = get(hCB, 'YColor');
            xCol = get(hCB, 'XColor');
            if iscell(yCol)
                yCol = cell2mat(yCol);
                xCol = cell2mat(xCol);
            end
            yCol = sum(yCol, 2);
            xCol = sum(xCol, 2);
        end
        % MATLAB "feature": apparently figure size can change when changing
        % colour in -nodisplay mode
        pos = get(fig, 'Position');
        % Set the background colour to black, and set size in case it was
        % changed internally
        tcol = get(fig, 'Color');
        set(fig, 'Color', 'k', 'Position', pos);
        % Correct the colorbar axes colours
        set(hCB(yCol==0), 'YColor', [0 0 0]);
        set(hCB(xCol==0), 'XColor', [0 0 0]);
        % Print large version to array
        B = print2array(fig, magnify, renderer);
        % Downscale the image
        B = downsize(single(B), options.aa_factor);
        % Set background to white (and set size)
        set(fig, 'Color', 'w', 'Position', pos);
        % Correct the colorbar axes colours
        set(hCB(yCol==3), 'YColor', [1 1 1]);
        set(hCB(xCol==3), 'XColor', [1 1 1]);
        % Print large version to array
        A = print2array(fig, magnify, renderer);
        % Downscale the image
        A = downsize(single(A), options.aa_factor);
        % Set the background colour (and size) back to normal
        set(fig, 'Color', tcol, 'Position', pos);
        % Compute the alpha map
        alpha = round(sum(B - A, 3)) / (255 * 3) + 1;
        A = alpha;
        A(A==0) = 1;
        A = B ./ A(:,:,[1 1 1]);
        clear B
        % Convert to greyscale
        if options.colourspace == 2
            A = rgb2grey(A);
        end
        A = uint8(A);
        % Crop the background
        if options.crop
            [alpha, v] = crop_background(alpha, 0);
            A = A(v(1):v(2),v(3):v(4),:);
        end
        if options.png
            % Compute the resolution
            res = options.magnify * get(0, 'ScreenPixelsPerInch') / 25.4e-3;
            % Save the png
            imwrite(A, [options.name '.png'], 'Alpha', double(alpha), 'ResolutionUnit', 'meter', 'XResolution', res, 'YResolution', res);
            % Clear the png bit
            options.png = false;
        end
        % Return only one channel for greyscale
        if isbitmap(options)
            A = check_greyscale(A);
        end
        if options.alpha
            % Store the image
            im = A;
            % Clear the alpha bit
            options.alpha = false;
        end
        % Get the non-alpha image
        if isbitmap(options)
            alph = alpha(:,:,ones(1, size(A, 3)));
            A = uint8(single(A) .* alph + 255 * (1 - alph));
            clear alph
        end
        if options.im
            % Store the new image
            im = A;
        end
    else
        % Print large version to array
        if options.transparent
            % MATLAB "feature": apparently figure size can change when changing
            % colour in -nodisplay mode
            pos = get(fig, 'Position');
            tcol = get(fig, 'Color');
            set(fig, 'Color', 'w', 'Position', pos);
            A = print2array(fig, magnify, renderer);
            set(fig, 'Color', tcol, 'Position', pos);
            tcol = 255;
        else
            [A, tcol] = print2array(fig, magnify, renderer);
        end
        % Crop the background
        if options.crop
            A = crop_background(A, tcol);
        end
        % Downscale the image
        A = downsize(A, options.aa_factor);
        if options.colourspace == 2
            % Convert to greyscale
            A = rgb2grey(A);
        else
            % Return only one channel for greyscale
            A = check_greyscale(A);
        end
        % Outputs
        if options.im
            im = A;
        end
        if options.alpha
            im = A;
            alpha = zeros(size(A, 1), size(A, 2), 'single');
        end
    end
    % Save the images
    if options.png
        res = options.magnify * get(0, 'ScreenPixelsPerInch') / 25.4e-3;
        imwrite(A, [options.name '.png'], 'ResolutionUnit', 'meter', 'XResolution', res, 'YResolution', res);
    end
    if options.bmp
        imwrite(A, [options.name '.bmp']);
    end
    % Save jpeg with given quality
    if options.jpg
        quality = options.quality;
        if isempty(quality)
            quality = 95;
        end
        if quality > 100
            imwrite(A, [options.name '.jpg'], 'Mode', 'lossless');
        else
            imwrite(A, [options.name '.jpg'], 'Quality', quality);
        end
    end
    % Save tif images in cmyk if wanted (and possible)
    if options.tif
        if options.colourspace == 1 && size(A, 3) == 3
            A = double(255 - A);
            K = min(A, [], 3);
            K_ = 255 ./ max(255 - K, 1);
            C = (A(:,:,1) - K) .* K_;
            M = (A(:,:,2) - K) .* K_;
            Y = (A(:,:,3) - K) .* K_;
            A = uint8(cat(3, C, M, Y, K));
            clear C M Y K K_
        end
        append_mode = {'overwrite', 'append'};
        imwrite(A, [options.name '.tif'], 'Resolution', options.magnify*get(0, 'ScreenPixelsPerInch'), 'WriteMode', append_mode{options.append+1});
    end
end
% Now do the vector formats
if isvector(options)
    % Set the default renderer to painters
    if ~options.renderer
        renderer = '-painters';
    end
    % Generate some filenames
    tmp_nam = [tempname '.eps'];
    if options.pdf
        pdf_nam = [options.name '.pdf'];
    else
        pdf_nam = [tempname '.pdf'];
    end
    % Generate the options for print
    p2eArgs = {renderer};
    if options.colourspace == 1
        p2eArgs = [p2eArgs {'-cmyk'}];
    end
    if ~options.crop
        p2eArgs = [p2eArgs {'-loose'}];
    end
    try
        % Generate an eps
        print2eps(tmp_nam, fig, p2eArgs{:});
        % Remove the background, if desired
        if options.transparent && ~isequal(get(fig, 'Color'), 'none')
            eps_remove_background(tmp_nam);
        end
        % Add a bookmark to the PDF if desired
        if options.bookmark
            fig_nam = get(fig, 'Name');
            if isempty(fig_nam)
                warning('export_fig:EmptyBookmark', 'Bookmark requested for figure with no name. Bookmark will be empty.');
            end
            add_bookmark(tmp_nam, fig_nam);
        end
        % Generate a pdf
        eps2pdf(tmp_nam, pdf_nam, 1, options.append, options.colourspace==2, options.quality);
    catch ex
        % Delete the eps
        delete(tmp_nam);
        rethrow(ex);
    end
    % Delete the eps
    delete(tmp_nam);
    if options.eps
        try
            % Generate an eps from the pdf
            pdf2eps(pdf_nam, [options.name '.eps']);
        catch ex
            if ~options.pdf
                % Delete the pdf
                delete(pdf_nam);
            end
            rethrow(ex);
        end
        if ~options.pdf
            % Delete the pdf
            delete(pdf_nam);
        end
    end
end
if cls
    % Close the created figure
    close(fig);
else
    % Reset the hardcopy mode
    set(fig, 'InvertHardcopy', old_mode);
    % Reset the axes limit and tick modes
    for a = 1:numel(Hlims)
        set(Hlims(a), 'XLimMode', Xlims{a}, 'YLimMode', Ylims{a}, 'ZLimMode', Zlims{a}, 'XTickMode', Xtick{a}, 'YTickMode', Ytick{a}, 'ZTickMode', Ztick{a});
    end
end
return

function [fig, options] = parse_args(nout, varargin)
% Parse the input arguments
% Set the defaults
fig = get(0, 'CurrentFigure');
options = struct('name', 'export_fig_out', ...
                 'crop', true, ...
                 'transparent', false, ...
                 'renderer', 0, ... % 0: default, 1: OpenGL, 2: ZBuffer, 3: Painters
                 'pdf', false, ...
                 'eps', false, ...
                 'png', false, ...
                 'tif', false, ...
                 'jpg', false, ...
                 'bmp', false, ...
                 'colourspace', 0, ... % 0: RGB/gray, 1: CMYK, 2: gray
                 'append', false, ...
                 'im', nout == 1, ...
                 'alpha', nout == 2, ...
                 'aa_factor', 3, ...
                 'magnify', 1, ...
                 'bookmark', false, ...
                 'quality', []);
native = false; % Set resolution to native of an image

% Go through the other arguments
for a = 1:nargin-1
    if all(ishandle(varargin{a}))
        fig = varargin{a};
    elseif ischar(varargin{a}) && ~isempty(varargin{a})
        if varargin{a}(1) == '-'
            switch lower(varargin{a}(2:end))
                case 'nocrop'
                    options.crop = false;
                case {'trans', 'transparent'}
                    options.transparent = true;
                case 'opengl'
                    options.renderer = 1;
                case 'zbuffer'
                    options.renderer = 2;
                case 'painters'
                    options.renderer = 3;
                case 'pdf'
                    options.pdf = true;
                case 'eps'
                    options.eps = true;
                case 'png'
                    options.png = true;
                case {'tif', 'tiff'}
                    options.tif = true;
                case {'jpg', 'jpeg'}
                    options.jpg = true;
                case 'bmp'
                    options.bmp = true;
                case 'rgb'
                    options.colourspace = 0;
                case 'cmyk'
                    options.colourspace = 1;
                case {'gray', 'grey'}
                    options.colourspace = 2;
                case {'a1', 'a2', 'a3', 'a4'}
                    options.aa_factor = str2double(varargin{a}(3));
                case 'append'
                    options.append = true;
                case 'bookmark'
                    options.bookmark = true;
                case 'native'
                    native = true;
                otherwise
                    val = str2double(regexp(varargin{a}, '(?<=-(m|M|r|R|q|Q))(\d*\.)?\d+(e-?\d+)?', 'match'));
                    if ~isscalar(val)
                        error('option %s not recognised', varargin{a});
                    end
                    switch lower(varargin{a}(2))
                        case 'm'
                            options.magnify = val;
                        case 'r'
                            options.magnify = val ./ get(0, 'ScreenPixelsPerInch');
                        case 'q'
                            options.quality = max(val, 0);
                    end
            end
        else
            [p, options.name, ext] = fileparts(varargin{a});
            if ~isempty(p)
                options.name = [p filesep options.name];
            end
            switch lower(ext)
                case {'.tif', '.tiff'}
                    options.tif = true;
                case {'.jpg', '.jpeg'}
                    options.jpg = true;
                case '.png'
                    options.png = true;
                case '.bmp'
                    options.bmp = true;
                case '.eps'
                    options.eps = true;
                case '.pdf'
                    options.pdf = true;
                otherwise
                    options.name = varargin{a};
            end
        end
    end
end

% Check we have a figure handle
if isempty(fig)
    error('No figure found');
end

% Set the default format
if ~isvector(options) && ~isbitmap(options)
    options.png = true;
end

% Check whether transparent background is wanted (old way)
if isequal(get(ancestor(fig, 'figure'), 'Color'), 'none')
    options.transparent = true;
end

% If requested, set the resolution to the native vertical resolution of the
% first suitable image found
if native && isbitmap(options)
    % Find a suitable image
    list = findobj(fig, 'Type', 'image', 'Tag', 'export_fig_native');
    if isempty(list)
        list = findobj(fig, 'Type', 'image', 'Visible', 'on');
    end
    for hIm = list(:)'
        % Check height is >= 2
        height = size(get(hIm, 'CData'), 1);
        if height < 2
            continue
        end
        % Account for the image filling only part of the axes, or vice
        % versa
        yl = get(hIm, 'YData');
        if isscalar(yl)
            yl = [yl(1)-0.5 yl(1)+height+0.5];
        else
            if ~diff(yl)
                continue
            end
            yl = yl + [-0.5 0.5] * (diff(yl) / (height - 1));
        end
        hAx = get(hIm, 'Parent');
        yl2 = get(hAx, 'YLim');
        % Find the pixel height of the axes
        oldUnits = get(hAx, 'Units');
        set(hAx, 'Units', 'pixels');
        pos = get(hAx, 'Position');
        set(hAx, 'Units', oldUnits);
        if ~pos(4)
            continue
        end
        % Found a suitable image
        % Account for stretch-to-fill being disabled
        pbar = get(hAx, 'PlotBoxAspectRatio');
        pos = min(pos(4), pbar(2)*pos(3)/pbar(1));
        % Set the magnification to give native resolution
        options.magnify = (height * diff(yl2)) / (pos * diff(yl));
        break
    end
end
return

function A = downsize(A, factor)
% Downsample an image
if factor == 1
    % Nothing to do
    return
end
try
    % Faster, but requires image processing toolbox
    A = imresize(A, 1/factor, 'bilinear');
catch
    % No image processing toolbox - resize manually
    % Lowpass filter - use Gaussian as is separable, so faster
    % Compute the 1d Gaussian filter
    filt = (-factor-1:factor+1) / (factor * 0.6);
    filt = exp(-filt .* filt);
    % Normalize the filter
    filt = single(filt / sum(filt));
    % Filter the image
    padding = floor(numel(filt) / 2);
    for a = 1:size(A, 3)
        A(:,:,a) = conv2(filt, filt', single(A([ones(1, padding) 1:end repmat(end, 1, padding)],[ones(1, padding) 1:end repmat(end, 1, padding)],a)), 'valid');
    end
    % Subsample
    A = A(1+floor(mod(end-1, factor)/2):factor:end,1+floor(mod(end-1, factor)/2):factor:end,:);
end
return

function A = rgb2grey(A)
A = cast(reshape(reshape(single(A), [], 3) * single([0.299; 0.587; 0.114]), size(A, 1), size(A, 2)), class(A));
return

function A = check_greyscale(A)
% Check if the image is greyscale
if size(A, 3) == 3 && ...
        all(reshape(A(:,:,1) == A(:,:,2), [], 1)) && ...
        all(reshape(A(:,:,2) == A(:,:,3), [], 1))
    A = A(:,:,1); % Save only one channel for 8-bit output
end
return

function [A, v] = crop_background(A, bcol)
% Map the foreground pixels
[h, w, c] = size(A);
if isscalar(bcol) && c > 1
    bcol = bcol(ones(1, c));
end
bail = false;
for l = 1:w
    for a = 1:c
        if ~all(A(:,l,a) == bcol(a))
            bail = true;
            break;
        end
    end
    if bail
        break;
    end
end
bail = false;
for r = w:-1:l
    for a = 1:c
        if ~all(A(:,r,a) == bcol(a))
            bail = true;
            break;
        end
    end
    if bail
        break;
    end
end
bail = false;
for t = 1:h
    for a = 1:c
        if ~all(A(t,:,a) == bcol(a))
            bail = true;
            break;
        end
    end
    if bail
        break;
    end
end
bail = false;
for b = h:-1:t
    for a = 1:c
        if ~all(A(b,:,a) == bcol(a))
            bail = true;
            break;
        end
    end
    if bail
        break;
    end
end
% Crop the background, leaving one boundary pixel to avoid bleeding on
% resize
v = [max(t-1, 1) min(b+1, h) max(l-1, 1) min(r+1, w)];
A = A(v(1):v(2),v(3):v(4),:);
return

function eps_remove_background(fname)
% Remove the background of an eps file
% Open the file
fh = fopen(fname, 'r+');
if fh == -1
    error('Not able to open file %s.', fname);
end
% Read the file line by line
while true
    % Get the next line
    l = fgets(fh);
    if isequal(l, -1)
        break; % Quit, no rectangle found
    end
    % Check if the line contains the background rectangle
    if isequal(regexp(l, ' *0 +0 +\d+ +\d+ +rf *[\n\r]+', 'start'), 1)
        % Set the line to whitespace and quit
        l(1:regexp(l, '[\n\r]', 'start', 'once')-1) = ' ';
        fseek(fh, -numel(l), 0);
        fprintf(fh, l);
        break;
    end
end
% Close the file
fclose(fh);
return

function b = isvector(options)
b = options.pdf || options.eps;
return

function b = isbitmap(options)
b = options.png || options.tif || options.jpg || options.bmp || options.im || options.alpha;
return

% Helper function
function A = make_cell(A)
if ~iscell(A)
    A = {A};
end
return

function add_bookmark(fname, bookmark_text)
% Adds a bookmark to the temporary EPS file after %%EndPageSetup
% Read in the file
fh = fopen(fname, 'r');
if fh == -1
    error('File %s not found.', fname);
end
try
    fstrm = fread(fh, '*char')';
catch ex
    fclose(fh);
    rethrow(ex);
end
fclose(fh);

% Include standard pdfmark prolog to maximize compatibility
fstrm = strrep(fstrm, '%%BeginProlog', sprintf('%%%%BeginProlog\n/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse'));
% Add page bookmark
fstrm = strrep(fstrm, '%%EndPageSetup', sprintf('%%%%EndPageSetup\n[ /Title (%s) /OUT pdfmark',bookmark_text));

% Write out the updated file
fh = fopen(fname, 'w');
if fh == -1
    error('Unable to open %s for writing.', fname);
end
try
    fwrite(fh, fstrm, 'char*1');
catch ex
    fclose(fh);
    rethrow(ex);
end
fclose(fh);
return
##### SOURCE END #####
--></body></html>