%%  MCMCcuedYesNo.m
%
%%

function [validHR, invalidHR] = evaluateCuedYesNoMCMC(opts, N, variance, cue_validity)
%  N=4; variance = 1; cue_validity=0.5; TRIALS =1000;

%% Preliminaries
JAGSmodel	= 'JAGScueddetection.txt';
mcmcparams	= define_mcmcparams(opts);


%% STEP 1: GENERATE SIMULATED DATASET
% Place observed variables into the structure |params| to pass to JAGS
params.N 				= N;
params.T                = 1;% simulate 1 trial, but generate many MCMC samples, see below
params.v                = cue_validity;
params.varT				= variance;
params.varD				= variance;
params.uniformdist      = ones(N,1)./N; % uniform distribution, for cue location

%%
% Set initial values for latent variable in each chain

for i=1:mcmcparams.generate.nchains
    %initial_param(i).L			= randi(params.N);
    
    % The guess initial parameter value for L cannot equal a location who's
    % spatial prior is equal to zero, otherwise we get an error message
    % from JAGS.
    
    initial_param(i).D = round( ( rand*(N)) +1);
end

%%
% Calling JAGS to generate simulated data
%fprintf( 'Running JAGS...\n' );
%tic
[dataset, stats, structArray] = matjags( ...
    params, ...
    fullfile(pwd, JAGSmodel), ...
    initial_param, ...
    'doparallel' , mcmcparams.doparallel, ...
    'nchains', mcmcparams.generate.nchains,...
    'nburnin', mcmcparams.generate.nburnin,...
    'nsamples', mcmcparams.generate.nsamples, ...
    'thin', 1, ...
    'monitorparams', {'c','D','x'}, ...
    'savejagsoutput' , 0 , ...
    'verbosity' , 1 , ...
    'cleanup' , 1 ,...
    'rndseed',1,...
    'dic',0);


clear initial_param


%%
% grab true locations from the dataset made in step 1
true_location = squeeze(dataset.D);









%% STEP 2: INFER THE TRIAL TYPE GIVEN THE SENSORY OBSERVATIONS
% Now do inference on ALL the generated data

% now we MAY OR MAY NOT want to remove knowledge that L is sampled from a uniform distribution over each location (pdist=[1/N ... 1/N])
%params = rmfield(params, 'pdist')

%%
% update some of the parameters
params.x		= squeeze(dataset.x)';
params.T		= opts.trials;
params.c		= squeeze(dataset.c)';

%%
% Set initial values for latent variable in each chain
for i=1:mcmcparams.infer.nchains
	initial_param(i).D			= randi(params.N+1, opts.trials, 1);
end

%%
% Calling JAGS to sample
[samples, stats, structArray] = matjags( ...
    params, ...
    fullfile(pwd, JAGSmodel), ...
    initial_param, ...
    'doparallel' , mcmcparams.doparallel, ...
    'nchains', mcmcparams.infer.nchains,...
    'nburnin', mcmcparams.infer.nburnin,...
    'nsamples', mcmcparams.infer.nsamples, ...
    'thin', 1, ...
    'monitorparams', {'D'}, ...
    'savejagsoutput' , 0 , ...
    'verbosity' , 1 , ...
    'cleanup' , 1 ,...
    'rndseed',1);


% %%
% % Extract the MCMC samples and use them to calculate the performance
% % (proportion correct, |PC|).
% 
% for t=1:TRIALS
%     D(t)		= mode( vec(samples.D(:,:,t)) );
% end
% 
% % Examine the performance of the optimal observer
% Ncorrect = sum( D==true_location );
% [PC, PCI] = binofit(Ncorrect,TRIALS);


%% STEP 3: Decision step

%%
% Calculate the decision variable for all trials. This is the posterior
% probability of the L indicating target presence, i.e. L={1,...,N} and not
% L=N+1 (indicating target absence).

% preallocate
Ppresent = zeros(params.T,1);
response = zeros(params.T,1);
for t=1:params.T
	% grab the MCMC samples of L for this trial, for all chains
	temp = vec( samples.D(:,:,t) );
	
	% Calculate the distribution over D (for each trial) as generated by the
	% MCMC samples
	[Dfreq,d] = hist(temp,[1:params.N+1]);
	
	% Normalise into a probability disibution over L.
	Dprob=Dfreq./sum(Dfreq);
	
	% Calculate the decision variable... the posterior probability the target
	% is present, i.e. the probability mass corresponding to L={1,...,N}
	Ppresent(t) = sum( Dprob([1:N]) );
	
	% What is the response of an unbiased observer?
	if Ppresent(t)>=0.5
		response(t)=1;
	else
		response(t)=0;
	end
end



% new ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
nValidHits = 0;	
nValidPresent = 0;
nInvalidHits = 0;	
nInvalidPresent = 0;

setValidHitTrials = zeros(params.T,1);
setInvalidHitTrials = zeros(params.T,1);

for t=1:params.T
	
	% Is this a target-present, valud-cue trial?
	if dataset.D(t)<=params.N && dataset.c(t)==dataset.D(t)
		nValidPresent = nValidPresent+1;
		
		% did the observer also get it right? A hit.
		if response(t)==1
			nValidHits = nValidHits+1;
			
			setValidHitTrials(t) = 1; % label as a validHit trial
		end
	end
	
	% Is this a target-present, INvalud-cue trial?
	if dataset.D(t)<=params.N && dataset.c(t)~=dataset.D(t)
		nInvalidPresent = nInvalidPresent+1;
		
		% did the observer also get it right? A hit.
		if response(t)==1
			nInvalidHits = nInvalidHits+1;
			
			setInvalidHitTrials(t) = 1; % label as a validHit trial
		end
	end
	
end
% nValidHits
% nValidPresent
validHR = nValidHits / nValidPresent;

% nInvalidHits
% nInvalidPresent
invalidHR = nInvalidHits / nInvalidPresent;
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





% % First, create binary vectors to label the signal (target present) and noise
% % (target absent) trials.
% present_trials	= dataset.D<=params.N;
% absent_trials	= dataset.D==params.N+1;
% 
% 
% %% 
% % Grab the decision variables for the signal and the noise trials
% S = Ppresent(present_trials);
% N = Ppresent(absent_trials);
% % Use that to calculate ROC curve with the function
% % |ROC_calcHRandFAR_VECTORIZED|.
% [HR, FAR, AUC]=ROC_calcHRandFAR_VECTORIZED(N,S);
% 
% % Grab the decision variables for the signal and the noise trials
% 
% % old
% % VP = Ppresent(valid_present_trials);
% % IP = Ppresent(invalid_present_trials);
% % new
% VP = Ppresent(setValidHitTrials==1);
% IP = Ppresent(setInvalidHitTrials==1);
% 
% 
% 
% % Use that to calculate ROC curve with the function
% % |ROC_calcHRandFAR_VECTORIZED|.
% [HR, FAR, AUC_valid_present]=ROC_calcHRandFAR_VECTORIZED(N,VP);
% 
% figure(5), clf
% subplot(2,2,1), hist_compare(N,VP,linspace(0,1,50))
% xlabel('P(present)')
% title('valid')
% 
% subplot(2,2,3), plot(FAR, HR), hold on, plot([0 1],[0 1],'k-')
% 
% [HR, FAR, AUC_invalid_present]=ROC_calcHRandFAR_VECTORIZED(N,IP);
% 
% subplot(2,2,2), hist_compare(N,IP,linspace(0,1,50))
% xlabel('decision variable, P(present)')
% title('invalid')
% 
% subplot(2,2,4), plot(FAR, HR), hold on, plot([0 1],[0 1],'k-')
% 
% drawnow

return